/*
 * -----------------------
 * --- DEVICE HANDLER ----
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
 * 1. the software will meet your requirements or expectations;
 * 2. the software or the software content will be free of bugs, errors, viruses or other defects;
 * 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
 * 4. the software will be compatible with third party software;
 * 5. any errors in the software will be corrected.
 * The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
 */ 
 
def clientVersion() {
    return "02.00.03"
}

/**
 * Monoprice Z-Wave Plug In Receptacle
 * 
 * Copyright RBoy Apps, redistribution or reuse of code is not allowed without permission
 * Change log:
 * 2020-10-15 - (v02.00.03) Support for new ST app UI custom controls, do refresh after configure
 * 2020-02-06 - (v01.01.06) Update device health
 * 2019-02-04 - (v01.01.05) Display overload cutoff in events list
 * 2019-01-14 - (v01.01.04) Update for restoring default values in preferences if invalid option is entered
 * 2018-08-05 - (v01.01.03) Added health check capability
 * 2018-08-02 - (v01.01.02) Added basic support for new ST app
 * 2018-02-14 - (v01.01.01) Show 1 decimal point for values and fix logging typo
 * 2018-02-02 - (v01.01.00) Added support for model 27481
 * 2017-08-14 - (v01.00.00) Initial public release
 *
 *  Copyright 2014 SmartThings
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 *
 */

preferences {
    input title: "", description: "Monoprice Plug In Receptacle Device Handler v${clientVersion()}", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input title: "", description: "You can define the behavior of the switch after a power failure, it can remain off, on or it can remember and restore it's last state before the power failure. Leave it blank to use the default values (Restore last state).", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "rememberLastState", "enum", title: "After power failure...", defaultValue: "Restore last state", displayDuringSetup: false, options: ["0": "Restore last state", "2": "Stay on", "1": "Stay off"], required: true
	input title: "[Advanced Settings]", description: "Set how often you would like the plug to report the statistics. Leave it blank to use the default values or 0 to disable.", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "meteringSensitivityA", "number", title: "...if power consumption changes by (watts)", required: false, displayDuringSetup: false, range: "0..65535"
    input "meteringSensitivityP", "number", title: "...if power consumption changes by (%)", required: false, displayDuringSetup: false, range: "0..255"
    input "meteringInterval", "number", title: "...report every (seconds)", required: false, displayDuringSetup: false, range: "0..2678400"
}


metadata {
	definition (name: "Monoprice Plug In Receptacle", namespace: "rboy", author: "RBoy Apps", ocfDeviceType: "oic.d.switch", mnmn: "SmartThingsCommunity", vid:"6d145089-656d-3896-80f7-f0fa7d9f181a") {
        capability "Actuator"
		capability "Sensor"
		capability "Energy Meter"
		capability "Power Meter"
        capability "Voltage Measurement"
        capability "Switch"
        capability "Relay Switch"
        capability "Outlet"
        capability "Indicator"
		capability "Refresh"
		capability "Polling"
        capability "Configuration"
		capability "Health Check"
        capability "rboyapps.currentMeasurement"
        capability "rboyapps.led"
        capability "rboyapps.loadLevel"
        capability "rboyapps.energyReset"
        capability "rboyapps.versioning"
        
        ///attribute "codeVersion", "string"
        ///attribute "dhName", "string"
        ///attribute "current", "number"
        ///attribute "loadLevel", "string"
        attribute "switchX", "string"

		///command "resetEnergy"

        // v1 fingerprints
        fingerprint deviceId:"0x1001", inClusters:"0x5E,0x25,0x32,0x27,0x2C,0x2B,0x70,0x85,0x59,0x72,0x86,0x7A,0x73,0x5A", manufacturer: "Monoprice", model: "27481"
        
        // New fingerprint format (MSR ==> mfr-prod-model)
        fingerprint type:"1001", mfr: "0208", prod: "0101", model: "0005", deviceJoinName:"Monoprice Plug In Receptacle (15654)" // , cc:"5E,25,32,27,2C,2B,70,85,59,72,86,7A,73,5A"
        fingerprint type:"1001", mfr:"0208", prod:"0101", model:"000A", deviceJoinName:"Monoprice Smart Plug and Repeater (27481)" // , cc:"5E,25,32,27,2C,2B,70,85,59,72,86,7A,73,5A"
	}

    tiles(scale: 2) {
        multiAttributeTile(name:"summary", type: "lighting", width: 6, height: 4, canChangeIcon: true){
			tileAttribute ("device.switchX", key: "PRIMARY_CONTROL") {
				attributeState "on", label: '${name}', action: "switch.off", icon: "st.switches.switch.on", backgroundColor: "#00A0DC", nextState: "off"
				attributeState "off", label: '${name}', action: "switch.on", icon: "st.switches.switch.off", backgroundColor: "#ffffff", nextState: "on"
                attributeState "heavyload", label:'${name}', action:"switch.off", icon:"st.switches.switch.on", backgroundColor: "#ffd700", nextState: "off"
				attributeState "overload", label: '${name}', action: "switch.on", icon: "st.switches.switch.off", backgroundColor: "#e86d13", nextState: "on"
			}
        }

		standardTile("ledindicator", "device.indicatorStatus", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			//state "when off", action:"indicator.indicatorWhenOn", icon:"st.indicators.lit-when-off", nextState: "checking"
			state "when on", action:"indicator.indicatorNever", icon:"st.indicators.lit-when-on", nextState: "checking"
			state "never", action:"indicator.indicatorWhenOn", icon:"st.indicators.never-lit", nextState: "checking"
			state "checking", label: '...', action:"", icon:""
		}
        
		valueTile("power", "device.power", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "default", label:'${currentValue} W'
		}
		
        valueTile("energy", "device.energy", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "default", label:'${currentValue} kWh', action:"resetEnergy"
		}
		
        standardTile("resetKWH", "device.energy", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "default", label:'reset kWh', action:"resetEnergy"
		}

		valueTile("voltage", "device.voltage", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "default", label:'${currentValue} V'
		}
		
		valueTile("amperage", "device.current", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "default", label:'${currentValue} A'
		}

        standardTile("overload", "device.loadLevel", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "normal", label:'', action:"", icon:"", backgroundColor: "#ffffff", defaultState: true
			state "heavyload", label:'Heavyload', action:"", icon:"", backgroundColor: "#ffd700"
			state "overload", label:'Overload', action:"", icon:"", backgroundColor: "#e86d13"
		}

        standardTile("refresh", "device.switch", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "default", label:'', action:"refresh.refresh", icon:"st.secondary.refresh"
		}

        standardTile("configure", "device.configure", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "default", label:'Configure', action:"configure"
		}

        standardTile("blank", "device.image", width: 1, height: 1, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
        	state "blank", label: "", action: "", icon: "", backgroundColor: "#FFFFFF"
        }
        
        standardTile("blank2x", "device.image", width: 2, height: 2, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
        	state "blank", label: "", action: "", icon: "", backgroundColor: "#FFFFFF"
        }
        
        main(["summary"])
        details(["summary", "autoOffTimerText", "autoOffTimer", "voltage", "ledindicator", "power", "amperage", "refresh", "energy"])
    }
}

import groovy.transform.Field

@Field final int RESET_DELAY = 2

// Sent delayed event
def delayedEvent(data) {
    log.trace "Sending delayed event: $data"
    sendEvent(data)
}

def uninstalled() {
    log.trace "Uninstalled called"
}

def installed() {
	log.trace "Installed called settings: $settings"

    // Device-Watch simply pings if no device events received for checkInterval duration of 32min = 2 * 15min + 2min lag time
	sendEvent(name: "checkInterval", value: 2 * 15 * 60 + 2 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID, offlinePingable: "1"])
	
    try {
		if (!state.init) {
			state.init = true
		}
        response(configure()) // Get the updates
	} catch (e) {
		log.warn "Installed() threw $e"
	}
}

def updated() {
	log.trace "Update called settings: $settings"

    // Device-Watch simply pings if no device events received for checkInterval duration of 32min = 2 * 15min + 2min lag time
	sendEvent(name: "checkInterval", value: 2 * 15 * 60 + 2 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID, offlinePingable: "1"])

    try {
		if (!state.init) {
			state.init = true
		}
        response(configure()) // Get the updates
	} catch (e) {
		log.warn "updated() threw $e"
	}
}

def ping() {
	log.trace "Ping called"
	// Just get device state, there's no need to flood more commands
	sendHubCommand(new physicalgraph.device.HubAction(command(zwave.switchBinaryV1.switchBinaryGet())))
}

def parse(String description) {
	//log.trace "$description"
    
    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Monoprice Plug In Receptacle"]) // Save DH Name for parent app

    def result = null
	if (description.startsWith("Err 106")) {
        log.warn("Z-Wave error '$description'")
		state.sec = 0
		result = createEvent(descriptionText: description, isStateChange: true)
	} else if (description != "updated") {
		def cmd = zwave.parse(description, [0x30:1, 0x32:3, 0x27:1, 0x2C:1, 0x2B:1, 0x70:1, 0x85:2, 0x72:2, 0x73:1, 0x98:1])
		if (cmd) {
			result = zwaveEvent(cmd)
			log.debug("Parsed to $result")
		} else {
			log.warn("Couldn't zwave.parse '$description'")
		}
	}
	result
}

def zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityMessageEncapsulation cmd) {
	def encapsulatedCommand = cmd.encapsulatedCommand([0x30:1, 0x32:3, 0x27:1, 0x2C:1, 0x2B:1, 0x70:1, 0x85:2])
	if (encapsulatedCommand) {
		state.sec = 1
		zwaveEvent(encapsulatedCommand)
	}
}

// Process switch on/off reports
private switchReport(cmd) {
    def result = []
    
    if (cmd.value && (device.currentValue("switch") != "on")) { // Clear event when it's switched on (e.g. power failure or unplugged) and not if the refresh button is pressed
        result << createEvent(name: "loadLevel", value: "normal", displayed: false) // Reset overload/heavyload on on/off
        result << createEvent(name: "switchX", value: "on", displayed: false)
    } else if (!cmd.value && device.currentValue("loadLevel") != "overload") { // Mark off only if we don't have an overload cutoff as it turns off on cutOff but we want to users to know about it
        result << createEvent(name: "switchX", value: "off", displayed: false)
    }

    result << createEvent(name: "switch", value: cmd.value ? "on" : "off", type: "physical") // TODO: How do we differentiate between physical and digital?
    
    result
}

def zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicReport cmd)
{
    log.trace "BasicReport: $cmd"
    switchReport(cmd)
}

def zwaveEvent(physicalgraph.zwave.commands.switchbinaryv1.SwitchBinaryReport cmd)
{
    log.trace "SwitchBinaryReport: $cmd"
    switchReport(cmd)
}

def zwaveEvent(physicalgraph.zwave.commands.switchallv1.SwitchAllReport cmd) {
    log.trace "SwitchAll: $cmd"
	[:]
}

def zwaveEvent(physicalgraph.zwave.commands.powerlevelv1.PowerlevelReport cmd) {
    log.trace "PowerLevel: $cmd"
	[:]
}

def zwaveEvent(physicalgraph.zwave.commands.associationv2.AssociationReport cmd) {
    log.trace "AssociationReport: $cmd"

    if (cmd.nodeId.any { it == zwaveHubNodeId }) {
        log.trace "$device.displayName is associated to $zwaveHubNodeId via group $cmd.groupingIdentifier"
    }
	[:]
}

def zwaveEvent(physicalgraph.zwave.commands.notificationv3.NotificationReport cmd) {
    log.trace "Notification: $cmd"
    
    def result = []
    switch (cmd.notificationType) {
        case physicalgraph.zwave.commands.notificationv3.NotificationReport.NOTIFICATION_TYPE_POWER_MANAGEMENT:
        	switch (cmd.event) {
                case 0x00:
                	switch (cmd.eventParameter[0]) {
                        case 0x08:
                            log.info "Cleared Overload CutOff event"
                            result << createEvent(name: "loadLevel", value: "normal", isStateChange: true, displayed: false)
                        	//result << createEvent(name: "switchX", value: device.currentValue("switch"), displayed: false) // Don't clear it here since we get false positives for clearing, it'll be done when the switch turns on next
                            break

                        default:
                            if (cmd.eventParameter) {
                                log.warn "Unknown Notification Type Power Cleared: $cmd"
                            }
	                        break
                    }
                    break
                    
                case 0x08:
                	log.info "Received Overload CutOff event"
                	result << createEvent(name: "loadLevel", value: "overload", descriptionText: "Overload cutoff detected", isStateChange: true, displayed: true)
                	result << createEvent(name: "switchX", value: "overload", isStateChange: true, displayed: false)
                	break

                default:
                    log.warn "Unknown Notification Type Power: $cmd"
	                break
        	}
        	break
            
        default:
            log.warn "Unknown Notification: $cmd"
            break
    }
    
    result
}

def zwaveEvent(physicalgraph.zwave.commands.meterv3.MeterReport cmd) {
    //log.trace "MeterReport: $cmd"
    
    def result = []
    
	if (cmd.scale == 0) {
		result << createEvent(name: "energy", value: (float) (Math.round(cmd.scaledMeterValue * 10.0) / 10.0), unit: "kWh")
	} else if (cmd.scale == 1) {
		result << createEvent(name: "energykVAh", value: (float) (Math.round(cmd.scaledMeterValue * 10.0) / 10.0), unit: "kVAh")
	} else if (cmd.scale == 2) {
		result << createEvent(name: "power", value: (float) (Math.round(cmd.scaledMeterValue * 10.0) / 10.0), unit: "W")
	} else if (cmd.scale == 4) {
		result << createEvent(name: "voltage", value: (float) (Math.round(cmd.scaledMeterValue * 10.0) / 10.0), unit: "V")
	} else if (cmd.scale == 5) {
		result << createEvent(name: "current", value: (float) (Math.round(cmd.scaledMeterValue * 10.0) / 10.0), unit: "A")
	} else {
        log.warn "Unknown Meter Report: $cmd"
    }
    
    result
}

def zwaveEvent(physicalgraph.zwave.commands.configurationv1.ConfigurationReport cmd) {
	log.trace "ConfigurationReport $cmd"
    def result = []
    switch (cmd.parameterNumber) {
        case paramMap.LoadChangeNotify.Param:
        	switch (cmd.configurationValue[0]) {
                case 0:
                	log.info "Load change notification reports Disabled"
                    break
                    
                case 1:
                	log.info "Load change notification reports Enabled"
                    break
                    
                case 2:
                	log.info "Load change notification reports Enabled for non Z-Wave commands"
                    break
                    
               default:
                	log.warn "Unknown load change notification reports state $cmd.configurationValue"
                    break
            }
            break
            
        case paramMap.MeteringFrequencyP.Param:
        	log.info "Metering power frequency ${getParamMap(cmd.configurationValue).MeteringFrequencyP.Value ?: "disabled"} seconds"
            break
            
        case paramMap.MeteringFrequencyE.Param:
        	log.info "Metering energy frequency ${getParamMap(cmd.configurationValue).MeteringFrequencyE.Value ?: "disabled"} seconds"
            break
            
        case paramMap.MeteringFrequencyV.Param:
        	log.info "Metering voltage frequency ${getParamMap(cmd.configurationValue).MeteringFrequencyV.Value ?: "disabled"} seconds"
            break
            
        case paramMap.MeteringFrequencyA.Param:
        	log.info "Metering amperage frequency ${getParamMap(cmd.configurationValue).MeteringFrequencyA.Value ?: "disabled"} seconds"
            break
            
        case paramMap.LED.Param:
        	switch (cmd.configurationValue[0]) {
                case paramMap.LED.Disabled:
    	            result << createEvent(name: "indicatorStatus", value: "never")
                    result << createEvent(name: "led", value: "off")
                	log.info "LED Off"
                    break
                    
                case paramMap.LED.Enabled:
	                result << createEvent(name: "indicatorStatus", value: "when on")
                    result << createEvent(name: "led", value: "on")
                	log.info "LED On"
                    break
                    
                default:
                	log.warn "Unknown LED state $cmd.configurationValue"
                    break
            }
            break
            
        case paramMap.MeteringThresholdA.Param:
        	log.info "Metering reporting absolute threshold ${getParamMap(cmd.configurationValue).MeteringThresholdA.Value ?: "disabled"} watts"
            break
            
        case paramMap.MeteringThresholdP.Param:
        	log.info "Metering reporting relative threshold ${getParamMap(cmd.configurationValue).MeteringThresholdP.Value ?: "disabled"}%"
            break
            
        case paramMap.OverloadProtection.Param:
            switch (cmd.configurationValue[0]) {
                case paramMap.OverloadProtection.Disabled:
                    log.info "OverLoad Protection Off"
                    break

                case paramMap.OverloadProtection.Enabled:
                    log.info "OverLoad Protection On"
                    break

                default:
                    log.warn "Unknown OverLoad Protection state $cmd.configurationValue"
                    break
            }
            break

        case paramMap.RememberLastState.Param:
            switch (cmd.configurationValue[0]) {
                case 0:
                    log.info "Remember last state after power fail"
                    break

                case 1:
                    log.info "Remember turn On after power fail"
                    break

                case 2:
                    log.info "Remember turn Off after power fail"
                    break

                default:
                    log.warn "Unknown Remember last state after power fail $cmd.configurationValue"
                    break
            }
            break
            
        default:
        	log.warn "Unknown configuration report: $cmd"
            break
    }
    
    result
}

def zwaveEvent(physicalgraph.zwave.commands.manufacturerspecificv2.ManufacturerSpecificReport cmd) {
	def result = []

	def msr = String.format("%04X-%04X-%04X", cmd.manufacturerId, cmd.productTypeId, cmd.productId)
	log.debug "msr: $msr"
	updateDataValue("MSR", msr)
	updateDataValue("manufacturer", cmd.manufacturerName)

    result << createEvent(descriptionText: "$device.displayName MSR: $msr", isStateChange: false)

	result
}

def zwaveEvent(physicalgraph.zwave.Command cmd) {
	log.warn "$device.displayName: $cmd"
	[:]
}

def on() {
    log.trace "Turning switch on"
    
    def cmds = []
    cmds << command(zwave.switchBinaryV1.switchBinarySet(switchValue: 0xFF))
    cmds << refresh(false)
    delayBetween(cmds, 1000)
}

def off() {
    log.trace "Turning switch off"
    
    def cmds = []
    cmds << command(zwave.switchBinaryV1.switchBinarySet(switchValue: 0x00))
    cmds << refresh(false)
    delayBetween(cmds, 1000)
}

def setLed(mode) {
	log.trace "Setting LED: $mode"
    switch (mode) {
        case "on":
        	enableLed()
            break
            
        case "off":
        	disableLed()
        	break
            
        default:
            log.error "Invalid mode: $mode"
            break
    }
}

def enableLed() {
    log.trace "Enabling LED"
    indicatorWhenOn()
}

def disableLed() {
    log.trace "Disabling LED"
    indicatorNever()
}

def indicatorWhenOn() {
    log.trace "LED On when switch is on"
	commands([
        zwave.configurationV1.configurationSet(parameterNumber: paramMap.LED.Param, configurationValue: [paramMap.LED.Enabled], size: paramMap.LED.Size),
        zwave.configurationV1.configurationGet(parameterNumber: paramMap.LED.Param)
    ])
}

def indicatorWhenOff() {
    log.warn "LED on when switch if off mode not supported"
}

def indicatorNever() {
    log.trace "LED off"
	commands([
        zwave.configurationV1.configurationSet(parameterNumber: paramMap.LED.Param, configurationValue: [paramMap.LED.Disabled], size: paramMap.LED.Size),
        zwave.configurationV1.configurationGet(parameterNumber: paramMap.LED.Param)
    ])
}

def setReset(delay = null) {
    log.trace "Resetting energy with delay $delay"
    resetEnergy()
}

def resetEnergy() {
    log.trace "Resetting energy"
    sendEvent(name: "resetEnergy", value: "resetting", isStateChange: true, descriptionText: "Resetting energy meter")
    runIn(RESET_DELAY, delayedEvent, [data: [name: "resetEnergy", value: "ready", isStateChange: true]])

    commands([
		zwave.meterV3.meterReset(),
		zwave.meterV3.meterGet(scale: 0),
	])
}

def refresh(queryConfig = true) {
    log.trace "Refresh called, refresh config params: ${queryConfig}"
    
    if (!device.currentValue("switchX")) {
        log.trace "Initializing switchX value"
        sendEvent(name: "switchX", value: device.currentValue("switch"), displayed: false)
    }
    
    def cmds = []

    //cmds << zwave.switchAllV1.switchAllGet()
    //cmds << zwave.powerlevelV1.powerlevelGet()
    cmds << zwave.switchBinaryV1.switchBinaryGet() // This only for digital
    //cmds << zwave.basicV1.basicGet() // This is only for physical
    cmds << zwave.meterV3.meterGet(scale: 0) // kWh
    cmds << zwave.meterV3.meterGet(scale: 2) // W
    cmds << zwave.meterV3.meterGet(scale: 4) // V
    cmds << zwave.meterV3.meterGet(scale: 5) // A

    if (queryConfig) {
        paramMap.each { key, value ->
            cmds << zwave.configurationV1.configurationGet(parameterNumber: value.Param)
        }
    }
    
    if (!queryConfig) { // Coming from a manual request, don't send command
        commands(cmds)
    } else {
        sendHubCommand(response(commands(cmds)).toHubAction()) // Send actions to hub since this is called offline
    }
}

def poll() {
    log.trace "Poll called"
	refresh()
}

def configure() {
    log.trace "Configure called\nZWInfo: ${zwaveInfo}}"
    
    sendEvent(name: "resetEnergy", value: "ready", displayed: false)

    if (device.currentValue("loadLevel") == null) {
        sendEvent(name: "loadLevel", value: "normal", displayed: false)
    }
    
    if (device.currentValue("current") == null) {
        sendEvent(name: "current", value: (float) (0.0), unit: "A")
    }
    
    def cmds = []
    
    if (!device.currentValue("switchX")) {
        log.trace "Initializing switchX value"
        sendEvent(name: "switchX", value: device.currentValue("switch"), displayed: false)
    }

    // Bug with ST firmware 18.x, since this device doesn't advertise secure capabilities in the CC list (0x98), ST doesn't so a secure association which is required for 15903 device, so we have to complete the assocaition manually and set the channel to secure
    if (zwaveInfo.zw && !zwaveInfo.zw.contains("s")) {
        log.debug "Non-secure inclusion"
    } else {
        log.debug "Forcing secure channel inclusion and communication"
        state.sec = 1
        cmds << zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:zwaveHubNodeId) // Bug with the 15903 device not publishing 0x98 in CC
    }

    log.debug "Getting MSR"
    cmds << zwave.manufacturerSpecificV2.manufacturerSpecificGet() // Get MSR

    log.debug "Enabling overload protection"
    cmds << zwave.configurationV1.configurationSet(parameterNumber: paramMap.OverloadProtection.Param, configurationValue: [paramMap.OverloadProtection.Enabled], size: paramMap.OverloadProtection.Size)

    log.debug "Setting power restore remember last state to ${rememberLastState?.isInteger() ? rememberLastState.toInteger() : "default value " + paramMap.RememberLastState.Default}"
    cmds << zwave.configurationV1.configurationSet(parameterNumber: paramMap.RememberLastState.Param, configurationValue: getParamMap(rememberLastState?.isInteger() ? rememberLastState.toInteger() : paramMap.RememberLastState.Default).RememberLastState.ParamValue, size: paramMap.RememberLastState.Size)

    log.debug "Enabling load change notifications"
    cmds << zwave.configurationV1.configurationSet(parameterNumber: paramMap.LoadChangeNotify.Param, configurationValue: [paramMap.LoadChangeNotify.Default], size: paramMap.LoadChangeNotify.Size)
    
    log.debug "Setting absolute power metering report change sensitivity to ${meteringSensitivityA != null ? meteringSensitivityA ?: "disabled" : paramMap.MeteringThresholdA.Default} watts"
    cmds << zwave.configurationV1.configurationSet(parameterNumber: paramMap.MeteringThresholdA.Param, configurationValue: getParamMap(meteringSensitivityA != null ? meteringSensitivityA : paramMap.MeteringThresholdA.Default).MeteringThresholdA.ParamValue, size: paramMap.MeteringThresholdA.Size) // Set highest sensitivity
    
    log.debug "Setting relative power metering report change sensitivity to ${meteringSensitivityP != null ? meteringSensitivityP ?: "disabled" : paramMap.MeteringThresholdP.Default} %"
    cmds << zwave.configurationV1.configurationSet(parameterNumber: paramMap.MeteringThresholdP.Param, configurationValue: getParamMap(meteringSensitivityP != null ? meteringSensitivityP : paramMap.MeteringThresholdP.Default).MeteringThresholdP.ParamValue, size: paramMap.MeteringThresholdP.Size) // Set highest sensitivity
    
    if (meteringInterval >=1 && meteringInterval < 5) {
        log.error "Metering report interval must be atleast 5 seconds, setting to 5 seconds"
        updateSetting("meteringInterval", 5)
    }

    log.debug "Settings power/energy/voltage/amperage metering report interval to ${meteringInterval != null ? meteringInterval ?: "disabled" : paramMap.MeteringFrequencyP.Default} seconds"
    cmds << zwave.configurationV1.configurationSet(parameterNumber: paramMap.MeteringFrequencyP.Param, configurationValue: getParamMap(meteringInterval != null ? meteringInterval : paramMap.MeteringFrequencyP.Default).MeteringFrequencyP.ParamValue, size: paramMap.MeteringFrequencyP.Size)
    cmds << zwave.configurationV1.configurationSet(parameterNumber: paramMap.MeteringFrequencyE.Param, configurationValue: getParamMap(meteringInterval != null ? meteringInterval : paramMap.MeteringFrequencyE.Default).MeteringFrequencyE.ParamValue, size: paramMap.MeteringFrequencyE.Size)
    cmds << zwave.configurationV1.configurationSet(parameterNumber: paramMap.MeteringFrequencyV.Param, configurationValue: getParamMap(meteringInterval != null ? meteringInterval : paramMap.MeteringFrequencyV.Default).MeteringFrequencyV.ParamValue, size: paramMap.MeteringFrequencyV.Size)
    cmds << zwave.configurationV1.configurationSet(parameterNumber: paramMap.MeteringFrequencyA.Param, configurationValue: getParamMap(meteringInterval != null ? meteringInterval : paramMap.MeteringFrequencyA.Default).MeteringFrequencyA.ParamValue, size: paramMap.MeteringFrequencyA.Size)

    // Get all parameters
    paramMap.each { key, value ->
        cmds << zwave.configurationV1.configurationGet(parameterNumber: value.Param)
    }
    
    runIn(60, refresh) // Give it 60 seconds to finish up and then get a refresh
    
    commands(cmds)
}

private command(physicalgraph.zwave.Command cmd) {
    //log.trace cmd
	if (state.sec) {
		zwave.securityV1.securityMessageEncapsulation().encapsulate(cmd).format()
	} else {
		cmd.format()
	}
}

private commands(commands, delay=1000) { // Some of these params need more time to get on this switch or they are dropped
	delayBetween(commands.collect{ command(it) }, delay)
}

// Update a user preference setting
private updateSetting(name, value) {
    device.updateSetting(name, value) // THIS IS A VERY SLOW TRANSACTION as it writes directly to the DB
}

// Delete a user preference setting
private deleteSetting(name) {
    device.updateSetting(name, '') // THIS IS A VERY SLOW TRANSACTION as it writes directly to the DB
}

private getParamMap(value = null) {
	[
        "OverloadProtection": 	[ Param: 20, Size: 1, Default: 1, Enabled: 1, Disabled: 0 ],
        "RememberLastState": 	[ Param: 21, Size: 1, Default: 0, Min: 0, Max: 2, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "LoadChangeNotify": 	[ Param: 24, Size: 1, Default: 1, Min: 0, Max: 2, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "LED": 					[ Param: 27, Size: 1, Default: 0, Enabled: 0, Disabled: 1 ],
        "MeteringThresholdA": 	[ Param: 151, Size: 2, Default: 50, Min: 0, Max: 65535, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "MeteringThresholdP": 	[ Param: 152, Size: 1, Default: 10, Min: 0, Max: 255, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "MeteringFrequencyP": 	[ Param: 171, Size: 4, Default: 30, Min: 0, Max: 2678400, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "MeteringFrequencyE": 	[ Param: 172, Size: 4, Default: 300, Min: 0, Max: 2678400, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "MeteringFrequencyV": 	[ Param: 173, Size: 4, Default: 300, Min: 0, Max: 2678400, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "MeteringFrequencyA": 	[ Param: 174, Size: 4, Default: 300, Min: 0, Max: 2678400, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
	]
}

private paramValue(value, bytes) {
    if (value == null || !(value instanceof Number)) {
        return null
    }
        
    //log.trace "Param value: $value, $bytes"

    List<Integer> ret = [] // We start with a Integer list and then convert to array (since arrays are fixed in size)
    for (int i=0; i<bytes; i++) {
        ret = [(((value as Long) >> (i*8)) & 0xFF) as Integer] + ret
    }
    
    //log.debug ret as Integer[]
    
    return ret as Integer[] // We need an integer array
}

private reverseValue(value) {
    if (!value || !List.isCase(value)) {
        return null
    }
        
    //log.trace "Reverse value: $value, $bytes"

    Long ret = 0
    for (int i=0; i<value.size(); i++) {
        ret |= ((((value[i] as Integer) & 0xFF) as Long) << ((value.size() - 1 - i) * 8)) as Long
    }
    
    //log.debug ret
    
    return ret
}

// THIS IS THE END OF THE FILE


