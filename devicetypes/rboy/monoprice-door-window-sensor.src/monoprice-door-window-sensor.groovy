/*
 * -----------------------
 * --- DEVICE HANDLER ----
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
 * 1. the software will meet your requirements or expectations;
 * 2. the software or the software content will be free of bugs, errors, viruses or other defects;
 * 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
 * 4. the software will be compatible with third party software;
 * 5. any errors in the software will be corrected.
 * The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
 */ 
 
def clientVersion() {
    return "02.01.06"
}

/**
 * Monoprice Door/Window Sensor
 * 
 * Copyright RBoy Apps, redistribution or reuse of code is not allowed without permission
 * Change log:
 * 2019-06-11 - (v02.01.06) Updated support for new ST app missing contact sensor
 * 2018-11-13 - (v02.01.05) Updated support for new ST app
 * 2018-11-13 - (v02.01.04) Updated support for new ST app
 * 2018-08-09 - (v02.01.03) Updated health check for 25259 sensor to wake up every 30 hours
 * 2018-08-05 - (v02.01.02) Added health check capability
 * 2018-08-02 - (v02.01.01) Added basic support for new ST app
 * 2018-02-19 - (v02.01.00) Added ability to switch between NC and NO for external sensor
 * 2018-02-01 - (v02.00.00) Added support for Monoprice open/close door sensor 24259
 * 2017-10-18 - (v01.00.01) Update tile layout with ST mobile app release 2.8.0
 * 2017-08-07 - (v01.00.00) Initial release
 *
 *  Copyright 2014 SmartThings
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 */

preferences {
    input title: "", description: "Monoprice Door/Window Sensor Device Handler v${clientVersion()}", displayDuringSetup: false, type: "paragraph", element: "paragraph"
	input title: "", description: "Some devices (e.g. 15270) can use an external wired sensor instead of the magnet sensor to trigger the open/close state.\nNOTE: To use the external wire sensor you MUST attach the magnet sensor to the device.", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "externalSensor", "bool", title: "External wired sensor", displayDuringSetup: false, required: false
	input title: "", description: "By default the device considers external sensors to be Normally Open (N/O), enable the option below if your external sensor is Normally Closed (N/C)", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "externalSensorNC", "bool", title: "External wired sensor is N/C", displayDuringSetup: false, required: false
}

metadata {
	definition (name: "Monoprice Door/Window Sensor", namespace: "rboy", author: "RBoy Apps", ocfDeviceType: "x.com.st.d.sensor.contact", mnmn: "SmartThings", vid: "generic-contact-5") {
		capability "Configuration"
		capability "Contact Sensor"
		capability "Sensor"
		capability "Battery"
        capability "Tamper Alert"
        capability "Health Check"
        
        attribute "codeVersion", "string"
        attribute "dhName", "string"

        fingerprint deviceId:"0x0701", inClusters:"0x5E,0x98,0x86,0x72,0x5A,0x85,0x59,0x73,0x80,0x71,0x84,0x7A", manufacturer: "Monoprice", model: "15268" // Z-Wave Plus Motion recessed Door/Windows sensor
        fingerprint deviceId:"0x0701", inClusters:"0x72,0x5A,0x80,0x73,0x86,0x84,0x85,0x59,0x71,0x70,0x7A", manufacturer: "Monoprice", model: "15270" // Z-Wave Plus Motion Door/Windows sensor
        fingerprint deviceId:"0x0701", inClusters:"0x5E,0x86,0x72,0x71,0x59,0x85,0x80,0x84,0x73,0x70,0x7A,0x5A", manufacturer: "Monoprice", model: "24259" // Z-Wave Plus Motion Door/Windows sensor
        
        // New fingerprint format (MSR ==> mfr-prod-model)
        fingerprint type:"0701", mfr: "0109", prod: "2022", model: "2201", deviceJoinName:"Monoprice Z-Wave Plus Recessed Door/Window Sensor (15268)" // cc:"5E,98", sec:"86,72,5A,85,59,73,80,71,84,7A", 
        fingerprint type:"0701", mfr: "0109", prod: "2001", model: "0106", deviceJoinName:"Monoprice Z-Wave Plus Door/Window Sensor (15270)" // cc:"5E,98", sec:"72,5A,80,73,86,84,85,59,71,70,7A", 
        fingerprint type:"0701", mfr: "0208", prod: "0201", model: "0008", deviceJoinName:"Monoprice Z-Wave Plus Door/Window Sensor (24259)" // cc:"5E,86,72,71,59,85,80,84,73,70,7A,5A", 

	}

	// UI tile definitions
    tiles(scale: 2) {
        multiAttributeTile(name:"summary", type: "generic", width: 6, height: 4, canChangeIcon: true) {
            tileAttribute ("device.contact", key: "PRIMARY_CONTROL") {
                attributeState "open", label: '${name}', icon: "st.contact.contact.open", backgroundColor: "#e86d13"
                attributeState "closed", label: '${name}', icon: "st.contact.contact.closed", backgroundColor: "#00A0DC"
            }
            tileAttribute ("device.battery", key: "SECONDARY_CONTROL") {
				attributeState "battery", label:'${currentValue}%'
            }
        }
		valueTile("battery", "device.battery", width: 2, height: 2, inactiveLabel: false) {
            state "battery", label:'${currentValue}%', unit: "", icon: "http://smartthings.rboyapps.com/images/battery.png",
                backgroundColors:[
                    [value: 15, color: "#ff0000"],
                    [value: 30, color: "#fd4e3a"],
                    [value: 50, color: "#fda63a"],
                    [value: 60, color: "#fdeb3a"],
                    [value: 75, color: "#d4fd3a"],
                    [value: 90, color: "#7cfd3a"],
                    [value: 99, color: "#55fd3a"]
                ]
        }
		standardTile("contact", "device.contact", width: 4, height: 4, inactiveLabel: false) {
			state "open", label: '${name}', icon: "st.contact.contact.open", backgroundColor: "#e86d13"
			state "closed", label: '${name}', icon: "st.contact.contact.closed", backgroundColor: "#00A0DC"
		}
		standardTile("tamper", "device.tamper", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "clear", label:'Request update', action:"configure", backgroundColor:"#FFFFFF", defaultState: true
			state "detected", label:'TAMPER', backgroundColor:"#e86d13"
		}

		main "contact"
        details(["contact", "battery", "tamper"])
	}
}

def parse(String description) {
    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Monoprice Door/Window Sensor Device Handler"]) // Save DH Name for parent app

	def result = null
	if (description.startsWith("Err 106")) {
		if (state.security) {
			log.debug description
		} else {
			result = createEvent(
				descriptionText: "This sensor failed to complete the network security key exchange. If you are unable to control it via SmartThings, you must remove it from your network and add it again.",
				eventType: "ALERT",
				name: "secureInclusion",
				value: "failed",
				isStateChange: true,
			)
		}
	} else if (description != "updated") {
		def cmd = zwave.parse(description, [0x20: 1, 0x25: 1, 0x30: 2, 0x80: 1, 0x84: 2, 0x71: 3, 0x9C: 1, 0x70: 1])
		if (cmd) {
			result = zwaveEvent(cmd)
		}
	}
    log.debug "Parse returned ${result}"
	return result
}

def installed() {
	log.trace "Installed called settings: $settings"
	// this is the nuclear option because the device often goes to sleep before we can poll it
	sendEvent(name: "contact", value: "open", descriptionText: "$device.displayName is open")
	sendEvent(name: "battery", unit: "%", value: 100)
	response(configure())
}

def updated() {
	log.trace "Update called settings: $settings"
	response(configure())
}

def configure() {
	log.trace "Configure called"
    
    state.setConfig = true // Set the config at next wakeup
    state.forceRefresh = true // Reset it to force a battery update on the next wake up
    
    // Configure is called at inclusion so we have a SMALL window to execute some commands here, won't make any differnce when called manually
    def cmds = []

	// Device-Watch simply pings if no device events received for 482min(checkInterval)
    if (zwaveInfo?.model == "0008") { // The 24259 is set to wake up by default never, so lets set it to wake up every 25 hours and check for an event about every 30 hours (sometimes the zwInfo isn't available initially)
        log.info "Found model 24259, setting health check interval to about 30 hours"
        sendEvent(name: "checkInterval", value: 30 * 60 * 60 + 2 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID])
        cmds << command(zwave.wakeUpV2.wakeUpIntervalSet(seconds:25*60*60, nodeid:zwaveHubNodeId)) // Set the wake up interval to 25 hours
        cmds << "delay 500"
    } else { // the 15268 and 15270 wake up every 6 hours so lets set it to check for an event about 8 every hours
        log.info "Settings health check interval to about 8 hours"
        sendEvent(name: "checkInterval", value: 2 * 4 * 60 * 60 + 2 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID])
    }

    cmds += commands([
        zwave.batteryV1.batteryGet(),
        zwave.manufacturerSpecificV2.manufacturerSpecificGet()
    ], 500) // Small delay works since typically at inclusion the sensor is near the hub for the NIF command so there's no routing involved here

    // Don't do a no more wakeup here as the hub ends up queueing it becase it's a passive device and it interfers with the wakup command due to a delayed retry from the hub, the device will timeout by itself in 10 seconds
    //cmds << "delay 3000"
    //cmds << command(zwave.wakeUpV1.wakeUpNoMoreInformation()) // We're done here
    
    return cmds
}


def sensorValueEvent(value) {
    def val
    if (externalSensor && externalSensorNC) {
        val = value ? 0 : 1 // Invert the value since we are NC instead of NO
    } else {
        val = value ? 1 : 0
    }
    
	if (val) {
		createEvent(name: "contact", value: "open", descriptionText: "$device.displayName is open")
	} else {
		createEvent(name: "contact", value: "closed", descriptionText: "$device.displayName is closed")
	}
}

def zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicReport cmd)
{
	log.trace "BasicReport: $cmd"
	sensorValueEvent(cmd.value)
}

def zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicSet cmd)
{
	log.trace "BasicSet: $cmd"
	sensorValueEvent(cmd.value)
}

def zwaveEvent(physicalgraph.zwave.commands.switchbinaryv1.SwitchBinaryReport cmd)
{
	log.trace "SwitchBinaryReport: $cmd"
	sensorValueEvent(cmd.value)
}

def zwaveEvent(physicalgraph.zwave.commands.sensorbinaryv2.SensorBinaryReport cmd)
{
	log.trace "SensorBinaryReport: $cmd"
	sensorValueEvent(cmd.sensorValue)
}

def zwaveEvent(physicalgraph.zwave.commands.sensoralarmv1.SensorAlarmReport cmd)
{
	log.trace "SensorAlarmReport: $cmd"
	sensorValueEvent(cmd.sensorState)
}

def zwaveEvent(physicalgraph.zwave.commands.notificationv3.NotificationReport cmd)
{
	log.trace "NotificationReport: $cmd"
	def result = []
	if (cmd.notificationType == 0x06 && (cmd.event == 0x16 || cmd.event == 0x17)) {
		result << sensorValueEvent(cmd.event == 0x16 ? 1 : 0) // Duplicate to BasicSet, whichever comes faster
	} else if (cmd.notificationType == 0x07) {
        if (cmd.event == 0x03) { // Bug, eventParameter is supposed to be 0x03 but it doesn't send it
            result << createEvent(name: "tamper", value: "detected", descriptionText: "$device.displayName covering was removed", isStateChange: true)
            state.forceRefresh = true // When the device is opened physically force a sensor refresh
		} else if (cmd.event == 0x00) {
            result << createEvent(name: "tamper", value: "clear", descriptionText: "$device.displayName covering was closed", isStateChange: true)
        }
	} else if (cmd.notificationType) {
		def text = "Notification $cmd.notificationType: event ${([cmd.event] + cmd.eventParameter).join(", ")}"
		result << createEvent(name: "notification$cmd.notificationType", value: "$cmd.event", descriptionText: text, displayed: false)
	} else {
		def value = cmd.v1AlarmLevel == 255 ? "active" : cmd.v1AlarmLevel ?: "inactive"
		result << createEvent(name: "alarm $cmd.v1AlarmType", value: value, displayed: false)
	}
	result
}

def zwaveEvent(physicalgraph.zwave.commands.wakeupv2.WakeUpNotification cmd)
{
	log.debug "Device woke up"
    
	def event = createEvent(descriptionText: "${device.displayName} woke up", isStateChange: false)
	def cmds = []

    if (!state.MSR) {
        log.debug "Getting device MSR"
		cmds << zwave.manufacturerSpecificV2.manufacturerSpecificGet()
	} else {
        log.debug "Saved MSR: $state.MSR"
    }

    if (state.setConfig) { // Set configuration
        if (state.MSR == "0109-2001-0106") { // Only the 15270 supports external sensor
            if (externalSensor) {
                log.info "Enabling external sensor"
                cmds << zwave.configurationV1.configurationSet(parameterNumber: 1, configurationValue: [0xFF]) // Set external sensor
                cmds << zwave.configurationV1.configurationGet(parameterNumber: 1) // Confirm
            } else {
                log.info "Disabling external sensor"
                cmds << zwave.configurationV1.configurationSet(parameterNumber: 1, configurationValue: [0x0]) // Set external sensor
                cmds << zwave.configurationV1.configurationGet(parameterNumber: 1) // Confirm inactivity timeout
            }
        }
        
        if (state.MSR == "0208-0201-0008") { // 24259 has default wake up set to 0 (never), wake once every 25 hours to get battery report (battery is update after 24 hours since lsat report)
            log.info "Settings wake up interval to 25 hours" // NOTE: Bug with firmware it doesn't set the value, it's always 0 (wake up when sensor opens)
            sendEvent(name: "checkInterval", value: 30 * 60 * 60 + 2 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID]) // Set device health event check interval to about 30 hours
            cmds << zwave.wakeUpV2.wakeUpIntervalSet(seconds:25*60*60, nodeid:zwaveHubNodeId) // Set the wake up interval
            cmds << zwave.wakeUpV2.wakeUpIntervalGet() // Check our current wake up interval
            cmds << zwave.wakeUpV2.wakeUpIntervalCapabilitiesGet() // Get Wake up interval capabilities
        }

        state.setConfig = false // We're done, dont' update again unless requested
    }

	if (state.forceRefresh || (device.currentValue("contact") == null)) { // Incase our initial request didn't make it or we are asking for a refresh
        log.debug "Getting sensor state"
		cmds << zwave.sensorBinaryV2.sensorBinaryGet(sensorType: zwave.sensorBinaryV2.SENSOR_TYPE_DOOR_WINDOW)
	}

    // Get battery updates every 24 hours to save battery
	if (state.forceRefresh || !state.lastbat || (now() - state.lastbat > 24*60*60*1000)) {
        log.debug "Getting battery level"
        cmds << zwave.batteryV1.batteryGet()
    }
    cmds << zwave.wakeUpV2.wakeUpNoMoreInformation()
    
    state.forceRefresh = false // We're done until the next request

	[event, getResponses(cmds)]
}

def zwaveEvent(physicalgraph.zwave.commands.batteryv1.BatteryReport cmd) {
	log.trace "BatteryReport: $cmd"
    
	def map = [ name: "battery", unit: "%" ]
	if (cmd.batteryLevel == 0xFF) {
        if (state.MSR == "0208-0201-0008") { // 24259 has low battery level set to 20% by default
            map.value = 20
        } else {
            map.value = 1
        }
		map.descriptionText = "${device.displayName} has a low battery"
		map.isStateChange = true
	} else {
		map.value = cmd.batteryLevel
	}
	state.lastbat = now()
	[createEvent(map)]
}

def zwaveEvent(physicalgraph.zwave.commands.wakeupv2.WakeUpIntervalReport cmd) {
    log.trace "WakeUpIntervalReport $cmd"
}

// NOTE: Bug with firmware it's always 0 (wake up when sensor opens)
// WakeUpIntervalCapabilitiesReport(defaultWakeUpIntervalSeconds: 0, maximumWakeUpIntervalSeconds: 0, minimumWakeUpIntervalSeconds: 0, wakeUpIntervalStepSeconds: 0)
def zwaveEvent(physicalgraph.zwave.commands.wakeupv2.WakeUpIntervalCapabilitiesReport cmd) {
    log.trace "WakeUpIntervalCapabilitiesReport $cmd"
}

def zwaveEvent(physicalgraph.zwave.commands.manufacturerspecificv2.ManufacturerSpecificReport cmd) {
	def result = []

	def msr = String.format("%04X-%04X-%04X", cmd.manufacturerId, cmd.productTypeId, cmd.productId)
	log.debug "msr: $msr"
	updateDataValue("MSR", msr)

	result << createEvent(descriptionText: "$device.displayName MSR: $msr", isStateChange: false)

    if (!device.currentState("battery")) {
        result << getResponse(zwave.batteryV1.batteryGet())
    }

	result
}

def zwaveEvent(physicalgraph.zwave.commands.configurationv1.ConfigurationReport cmd) {
	log.trace "ConfigurationReport $cmd"
    def result = []
    def msg = null
    switch (cmd.parameterNumber) {
        case 1:
        	switch (cmd.configurationValue[0]) {
                case 0xFF:
	        		msg = "External wire sensor Enabled, Magnet sensor Disabled"
                	result << createEvent(descriptionText: "$device.displayName $msg", displayed: true, isStateChange:false)
    	            break
                
                case 0x0:
	        		msg = "External wire sensor Disabled, Magnet sensor Enabled"
                	result << createEvent(descriptionText: "$device.displayName $msg", displayed: true, isStateChange:false)
                    break

                default:
                    log.warn "Invalid External Sensor Mode: ${cmd.configurationValue[0]}"
                	break
            }
            break
            
        default:
            log.warn "Unknown parameter"
            break
    }
    
    log.info msg
    result
}

def zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityMessageEncapsulation cmd) {
	def encapsulatedCommand = cmd.encapsulatedCommand([0x20: 1, 0x25: 1, 0x30: 2, 0x80: 1, 0x84: 2, 0x71: 3, 0x9C: 1, 0x70: 1])
	// log.debug "encapsulated: $encapsulatedCommand"
	if (encapsulatedCommand) {
		state.security = true
		zwaveEvent(encapsulatedCommand)
	}
}

def zwaveEvent(physicalgraph.zwave.Command cmd) {
	log.warn "Unhandled command: $cmd"
	createEvent(descriptionText: "$device.displayName: $cmd", displayed: false)
}

private getResponses(commands, delay=1200) {
    if (state.security) {
        response(delayBetween(commands.collect{ zwave.securityV1.securityMessageEncapsulation().encapsulate(it).format() }, delay))
    } else {
        response(delayBetween(commands.collect{ it.format() }, delay))
    }
}

private getResponse(command) {
    if (state.security) {
        response(zwave.securityV1.securityMessageEncapsulation().encapsulate(command).format())
    } else {
        response(command.format())
    }
}

private command(physicalgraph.zwave.Command cmd) {
	if (state.security) {
		zwave.securityV1.securityMessageEncapsulation().encapsulate(cmd).format()
	} else {
		cmd.format()
	}
}

private commands(commands, delay=200) {
	delayBetween(commands.collect{ command(it) }, delay)
}

// THIS IS THE END OF THE FILE